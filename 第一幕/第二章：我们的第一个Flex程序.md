
# 我们的第一个 Flex 程序

Unix 系统（同样也包括像 Linux 和 BSD 这样的类 Unix 系统）自带了一个字数统计（word count）程序，这个程序可以读入一个文件然后报告这个文件的行数、单词数和字符数。  
flex 使我们能够用仅仅十几行就完成这个 wc 程序，见例 1-1。  

### 例 1-1：字数统计 fl-1.1  

```c
/* 正如 Unix 的 wc 程序 */
%{
int chars = 0;
int words = 0;
int lines = 0;
%}
%%
[a-zA-Z]+   { words++; chars += strlen(yytext); }
\n          { chars++; lines++; }
.           { chars++; }
%%

main(int argc, char **argv)
{
yylex();
printf("%d%d%d\n", lines, words, chars);
}
```

这个程序的大部分内容对于 C 程序员来说是十分熟悉的，因为这些就是 C 代码。flex 程序包含三个部分，各部分之间通过仅有 `%` 的行来分割：  
1. **第一部分**：包含声明和选项设置  
2. **第二部分**：是一系列的模式和动作  
3. **第三部分**：则是会被拷贝到生成的词法分析器里面的 C 代码，它们通常是一些与动作代码相关的例程  

#### 声明部分  
`%{` 和 `%}` 之间的代码会被原样照抄到生成的 C 文件的开头部分。在这个例子里面，它只是用来设定了行数、单词数和字符数的变量。  

#### 模式与动作部分  
每个模式处在一行的开头处，接着是模式匹配时所需要执行的 C 代码（用 `{}` 括住的一行或者多行语句）。  

> （模式必须在行首出现，因为 flex 认为以空白开始的行都是代码而把它们照抄到生成的 C 程序中。）

这个程序只有三个模式：  
1. **`[a-zA-Z]+`**：  
   用来匹配一个单词。方括号内的字符串是**字符类（character class）**，可匹配任意一个大小写字母；`+` 表示匹配一个或多个前面的字符类（即一连串字母，也就是一个单词）。  
   相关动作：更新匹配过的单词数 `words`，以及通过 `strlen(yytext)` 统计字符数累加到 `chars`（`yytext` 是 flex 动作中指向本次匹配输入文本的变量）。  

2. **`\n`**：  
   用来匹配换行符。  
   相关动作：更新行数 `lines` 和字符数 `chars`。  

3. **`.`**：  
   匹配除换行符外的任意单个字符。  
   相关动作：更新字符数 `chars`。  

### 内容整理
最后的模式是一个点号，它在正则表达式中代表任意一个字符（与 shell 脚本中的?相似）。关联的动作更新字符数。这些就是我们需要的所有模式（注 2）。  

末尾的 C 代码是我们的主程序，它负责调用 flex 提供的词法分析例程 `yylex()`，并输出结果。在没有任何其他改变的情况下，词法分析器将读取标准输入。我们来运行一下：  

```bash
$ flex fb-1.1  
$ cc lex.yy.c -lfl  
$ ./a.out  
The boy stood on the burning deck  
shelling peanuts by the peck  
^D  
2 12 63  
$  
```

首先我们用 flex 来翻译我们的程序，flex 在没有任何错误的情况下默默地完成了翻译，正如 Unix 的经典设定那样。接着我们编译 flex 生成的 C 程序：`lex.yy.c`，将它与相应的 flex 库文件（`-lfl`）链接，运行它；然后提供一小段输入以便于程序进行统计。看起来一切运作正常。  

真正的 wc 程序对单词的定义和这儿相比有些微小的差别，它的定义是没有空白字符的字符串。一旦我们知道哪些是空白字符，我们只需把匹配单词的那个模式替换成匹配没有空白字符的字符串：  

```c
[^ \t\n\r\f\v]+ { words++; chars += strlen(yytext); } 
```

在字符类开始部分的符号 `^` 是指匹配任意一个不在字符类里面的字符，而符号 `+` 依然意味着匹配一个或者多个前面的模式。这展示了 flex 的强大之一——我们很容易在模式上做一些小的改动而让 flex 去担心它们可能怎样影响生成的代码。  

#### 纯 Flex 的程序  
一些应用程序简单到你可以把所有的内容都写在 flex 里面，或者只是增加一点点 C 代码。例如，例 1-2 就实现了从英式英语到美式英语的翻译器框架。  

**例 1-2：英式英语到美式英语 [b1-2.1]**  

```c
/* 英式英语 -> 美式英语 */  
%%  
"colour" { printf("color"); }  
"favour" { printf("flavor"); }
"clever" { printf("smart"); }
"smart" { printf("elegant"); }
"conservative" { printf("liberal"); }
...其他更多的单词...
. { printf("%s", yytext); }
%%
```

> **注 2**：也许旁观的读者会问，如果一个点号代表所有的字符，难道它不会也匹配第一个模式所应该匹配的字母吗？答案是肯定的，但是 flex 棋高一着的地方是它总是选择更长的匹配，而且如果两个模式都匹配的话，flex 会选择在程序里面首先出现的那个模式。这是一个精妙的设计，我们会发现它非常有用。

这个程序读取其输入，当匹配到一个英语单词时就打印出其美式版本，否则就直接输出。这个例子在一定意义上显得并不真实（毕竟smart也有可能是hurt的意思），但是flex还是比较适合用来进行一定程度上的文本转换和输入统计的。当然，更多情况下你会用flex生成词法分析器——它可以把输入分解成为记号以便于你的程序的其他部分来使用。

## 让Flex和Bison协同工作
我们的第一个同时使用flex和bison的程序将是一个桌面计算器（desk calculator）。首先，我们编写一个词法分析器，接着我们编写一个语法分析器并把两者接合起来。

为了让事情变得简单，我们的计算器只需要识别整数、基本算术运算符和一元绝对值操作符（例1-3）。

### 例1-3：一个简单的flex词法分析器fb1-3.l
```c
/* 识别出用于计算器的记号并把它们输出*/
%%
"+"     { printf("PLUS\n"); }
"-"     { printf("MINUS\n"); }
"*"     { printf("TIMES\n"); }
"/"     { printf("DIVIDE\n"); }
"|"     { printf("ABS\n"); }
[0-9]+  { printf("NUMBER %s\n", yytext); }
\n      { printf("NEWLINE\n"); }
[ \t]   { }
.       { printf("Mystery character %s\n", yytext); }
%%
```

前5个模式就是操作符本身，用引号引起，而目前的动作仅仅是打印出匹配的内容。引号告诉flex使用引号内文本的原义，而不是把它们解释成正则表达式。

第6个模式匹配一个整数。这种方括号括起的模式`[0-9]`可以匹配任意一个数字，接着的`+`这个符号表示匹配一个或者多个前面的项，也就是由一个或者多个数字组成的字符串。相关的动作利用词法分析器每次匹配后所设置的`yytext`来打印出匹配的字符串。

第7个模式匹配一个换行符，它使用C语言通常使用的序列：`\n`。

第8个模式用来忽略空白字符。它匹配任意一个空格或者tab（`\t`），相关的动作无需做任何事情。  

最后一个模式用来匹配其他模式所没有匹配的内容。相关的动作打印出恰当的抱怨信息。  

这9个模式提供了一定的规则来匹配用户可能的输入。随着我们继续开发计算器，我们将添加更多的规则来匹配更多的记号，但这些已经可以作为我们的开始部分。  

在这个简单的flex程序中，我们并没有第三段的C代码。flex库文件（`-lfl`）提供了一个极小的主程序来调用词法分析器，这对我们的例子来说已经足够。  

让我们试验一下这个词法分析器：  

```bash
$ flex fb1-3.1  
$ cc lex.yy.c -lfl  
$ ./a.out  
12*34  
NUMBER 12  
PLUS  
NUMBER 34  
NEWLINE  
5 6 / 7q  
NUMBER 5  
NUMBER 6  
DIVIDE  
NUMBER 7  
Mystery character q  
NEWLINE  
^D  
$  
```

首先我们运行flex，它把词法分析器翻译成C程序（`lex.yy.c`），接着我们编译这个C程序并最终运行它。输出结果表明它可以识别数字、操作符以及最后一行的q（匹配最后的那个包罗万象的模式）。（^D是Unix/Linux的文件结束符。在Windows中，你可以输入^Z。）  

### 作为协同程序的词法分析器  
大多数包含flex词法分析器的程序使用词法分析器来获得一个记号流，这样可以方便语法分析器的处理。每当程序需要一个记号时，它调用`yylex()`来读取一小部分输入然后返回相应的记号。当程序需要下一个记号时，`yylex()`会被再次调用。词法分析器以协同程序的方式来运行，也就是说，每次它返回的时候，它会记住当前处理的位置，并从这个位置开始去处理下一次调用。  

在词法分析器中，当动作代码识别出一个记号时，`yylex()`将以这个记号作为返回值。当程序再次调用`yylex()`时，词法分析器会以后续的输入字符继续分析。相反，如果一个模式不能够产生一个用于调用程序且不可以返回的记号时，词法分析器会在这次`yylex()`的调用中继续分析接下来的输入字符。下面这个并不完整的片段包含了两个可以返回记号的模式，一个返回`+`操作符，另一个返回数字；它还包含一个不做任何事情的空白字符的模式，这个模式用来忽略它所匹配的内容。  

```c
"+"     { return ADD; }
[0-9]+  { return NUMBER; }
[ \t]   { /* 忽略空白字符 */ }
```

这种看起来并不确定的返回方式经常会迷惑 flex 的新手，但是这种规则事实上非常简单：如果动作有返回，词法分析会在下一次 `yylex()` 调用时继续；如果动作没有返回，词法分析将会立即继续进行。

现在我们将修改我们的词法分析器，它所返回的记号可以被语法分析器用来实现一个计算器。

## 记号编号和记号值
当 flex 词法分析器返回一个记号流时，每个记号实际上有两个组成部分，记号编号（token number）和记号值（token's value）。这里的记号编号是一个较小的整数。这个数字是随意确定的，但是零值总是意味着文件的结束。当 bison 创建一个语法分析器时，bison 自动地从 258（这样可以避免与文字字符记号产生冲突，后面会详细讨论）起指派每个记号编号，并且创建一个包含这些编号定义的.h 文件。不过这次我们将手工定义一些编号：

```c
enum {
    NUMBER = 258,
    ADD    = 259,
    SUB    = 260,
    MUL    = 261,
    DIV    = 262,
    ABS    = 263,
    EOL    = 264 //行结束 
};
```

（当然，事实上，正如我们后面会看到的，它们也就是 bison 所创建的记号编号列表。但是这些编号一样好用。）

记号值可以区分一组相似的记号。在我们的词法分析器中，所有的数字都属于 Number 这个记号，而记号值则表明了具体的数字。当分析更复杂的输入时（名称、浮点数、字符串字面值等等），记号值将告诉我们具体的名称、数字、字面值和其他内容。我们第一版的计算器的词法分析器带有一个用于调试的主程序，参见例 1-4。

### 例1-4：计算器词法分析器 fb1-4.l  
```c
/* 识别出用于计算器的记号并把它们输出 */
%{
    enum yytokentype {
        NUMBER = 258,
        ADD = 259,
        SUB = 260,
        MUL = 261,
        DIV = 262,
        ABS = 263,
        EOL = 264
    };
    int yylval;
%}

%%
"+"     { return ADD; }
"-"     { return SUB; }
"*"     { return MUL; }
"/"     { return DIV; }
"|"     { return ABS; }
[0-9]+  { yylval = atoi(yytext); return NUMBER; }
\n      { return EOL; }
[ \t]   { }
.       { printf("Mystery character %s\n", yytext); }
%%

main(int argc, char **argv)
{
    int tok;
    while(tok = yylex()) {
        printf("%d", tok);
        if(tok == NUMBER) printf(" = %d\n", yylval);
        else printf("\n");
    }
}
```

我们在一个 C 语言的enum中定义记号编号。接着我们把`yylval`（这个变量用来储存记号值）定义为整型，这对于我们第一版的计算器来说已经足够。（后面我们会看到记号值通常被定义为联合类型以便于不同类型的记号可以拥有不同类型的记号值，例如，符号表中的浮点数或者指向一个符号项的指针。）

这里的模式列表与前面的例子相同，但是动作代码有所不同。对于每个记号，词法分析器返回适当的记号代码；对于编号，它把数字字符串转成整数并在返回前储存到`yylval`中。匹配空白字符的模式并不返回，所以词法分析器会继续分析接下来的输入。

出于测试的目的，主程序将调用`yylex()`，打印出记号值，并且对于Number记号，也会输出`yylval`。

```bash
$ cc lex.yy.c -lfl
$ ./a.out
a / 34 + |45
Mystery character a
262
258 = 34
259
263
258 = 45
264
^D
$
```

现在我们就有了一个能够工作的词法分析器，我们可以把注意力转向语法分析器。
